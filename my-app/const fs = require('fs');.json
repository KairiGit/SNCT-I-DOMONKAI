const fs = require('fs');
const path = require('path');
const semver = require('semver');

describe('package-lock.json validation', () => {
  let packageLock;
  let packageJson;

  beforeAll(() => {
    // Load package-lock.json
    const packageLockPath = path.join(__dirname, '../package-lock.json');
    packageLock = JSON.parse(fs.readFileSync(packageLockPath, 'utf8'));
    
    // Load package.json for comparison
    const packageJsonPath = path.join(__dirname, '../package.json');
    packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  });

  describe('Basic structure validation', () => {
    test('should have required top-level properties', () => {
      expect(packageLock).toHaveProperty('name');
      expect(packageLock).toHaveProperty('version');
      expect(packageLock).toHaveProperty('lockfileVersion');
      expect(packageLock).toHaveProperty('requires');
      expect(packageLock).toHaveProperty('packages');
    });

    test('should have correct lockfileVersion', () => {
      expect(packageLock.lockfileVersion).toBe(3);
    });

    test('should match package.json name and version', () => {
      expect(packageLock.name).toBe(packageJson.name);
      expect(packageLock.version).toBe(packageJson.version);
    });
  });

  describe('Dependencies validation', () => {
    test('should have all required production dependencies', () => {
      const requiredDeps = [
        '@heroicons/react',
        'next',
        'react',
        'react-dom'
      ];

      requiredDeps.forEach(dep => {
        expect(packageLock.packages['']).toHaveProperty('dependencies');
        expect(packageLock.packages[''].dependencies).toHaveProperty(dep);
      });
    });

    test('should have all required development dependencies', () => {
      const requiredDevDeps = [
        '@eslint/eslintrc',
        '@tailwindcss/postcss',
        '@types/node',
        '@types/react',
        '@types/react-dom',
        'eslint',
        'eslint-config-next',
        'tailwindcss',
        'typescript'
      ];

      requiredDevDeps.forEach(dep => {
        expect(packageLock.packages['']).toHaveProperty('devDependencies');
        expect(packageLock.packages[''].devDependencies).toHaveProperty(dep);
      });
    });

    test('should have valid version ranges for Next.js', () => {
      const nextVersion = packageLock.packages[''].dependencies.next;
      expect(semver.valid(nextVersion.replace(/^\^/, ''))).toBeTruthy();
      expect(semver.gte(nextVersion.replace(/^\^/, ''), '15.0.0')).toBe(true);
    });

    test('should have compatible React versions', () => {
      const reactVersion = packageLock.packages[''].dependencies.react;
      const reactDomVersion = packageLock.packages[''].dependencies['react-dom'];
      
      expect(reactVersion).toBe(reactDomVersion);
      expect(semver.gte(reactVersion.replace(/^\^/, ''), '19.0.0')).toBe(true);
    });
  });

  describe('Node modules structure validation', () => {
    test('should have node_modules entries for all dependencies', () => {
      const deps = Object.keys(packageLock.packages[''].dependencies || {});
      
      deps.forEach(dep => {
        expect(packageLock.packages).toHaveProperty(`node_modules/${dep}`);
      });
    });

    test('should have correct resolved URLs', () => {
      Object.entries(packageLock.packages).forEach(([key, pkg]) => {
        if (key.startsWith('node_modules/') && pkg.resolved) {
          expect(pkg.resolved).toMatch(/^https:\/\/registry\.npmjs\.org\//);
        }
      });
    });

    test('should have integrity hashes for packages', () => {
      Object.entries(packageLock.packages).forEach(([key, pkg]) => {
        if (key.startsWith('node_modules/') && pkg.resolved) {
          expect(pkg).toHaveProperty('integrity');
          expect(pkg.integrity).toMatch(/^sha\d+-/);
        }
      });
    });
  });

  describe('Security and license validation', () => {
    test('should have license information for packages', () => {
      const packagesWithoutLicense = [];
      
      Object.entries(packageLock.packages).forEach(([key, pkg]) => {
        if (key.startsWith('node_modules/') && !pkg.license && !pkg.optional) {
          packagesWithoutLicense.push(key);
        }
      });

      // Allow some packages to not have license info (build tools, etc.)
      expect(packagesWithoutLicense.length).toBeLessThan(10);
    });

    test('should not contain known vulnerable package versions', () => {
      // Check for commonly vulnerable packages
      const vulnerablePatterns = [
        { name: 'lodash', versions: ['<4.17.21'] },
        { name: 'axios', versions: ['<0.21.1'] },
        { name: 'tar', versions: ['<6.1.2'] }
      ];

      vulnerablePatterns.forEach(({ name, versions }) => {
        const packagePath = `node_modules/${name}`;
        if (packageLock.packages[packagePath]) {
          const version = packageLock.packages[packagePath].version;
          versions.forEach(vulnVersion => {
            expect(semver.satisfies(version, vulnVersion)).toBe(false);
          });
        }
      });
    });
  });

  describe('TypeScript and build tools validation', () => {
    test('should have TypeScript dependencies', () => {
      expect(packageLock.packages).toHaveProperty('node_modules/typescript');
      expect(packageLock.packages).toHaveProperty('node_modules/@types/node');
      expect(packageLock.packages).toHaveProperty('node_modules/@types/react');
      expect(packageLock.packages).toHaveProperty('node_modules/@types/react-dom');
    });

    test('should have ESLint configuration', () => {
      expect(packageLock.packages).toHaveProperty('node_modules/eslint');
      expect(packageLock.packages).toHaveProperty('node_modules/eslint-config-next');
      expect(packageLock.packages).toHaveProperty('node_modules/@typescript-eslint/eslint-plugin');
      expect(packageLock.packages).toHaveProperty('node_modules/@typescript-eslint/parser');
    });

    test('should have TailwindCSS setup', () => {
      expect(packageLock.packages).toHaveProperty('node_modules/tailwindcss');
      expect(packageLock.packages).toHaveProperty('node_modules/@tailwindcss/postcss');
    });
  });

  describe('Platform compatibility', () => {
    test('should have platform-specific packages when needed', () => {
      // Check for Next.js SWC binaries
      const swcPackages = Object.keys(packageLock.packages).filter(key => 
        key.includes('@next/swc-') || key.includes('@img/sharp-')
      );
      
      expect(swcPackages.length).toBeGreaterThan(0);
    });

    test('should have correct engine requirements', () => {
      const nodePackages = Object.entries(packageLock.packages).filter(([key, pkg]) => 
        pkg.engines && pkg.engines.node
      );

      nodePackages.forEach(([key, pkg]) => {
        expect(pkg.engines.node).toMatch(/>=|>|\^/);
      });
    });
  });

  describe('Dependency tree integrity', () => {
    test('should not have duplicate packages at different versions', () => {
      const packageVersions = {};
      
      Object.entries(packageLock.packages).forEach(([key, pkg]) => {
        if (key.startsWith('node_modules/')) {
          const packageName = key.replace(/^node_modules\//, '').split('/')[0];
          if (!packageVersions[packageName]) {
            packageVersions[packageName] = [];
          }
          packageVersions[packageName].push(pkg.version);
        }
      });

      // Allow some packages to have multiple versions (common in large projects)
      const duplicates = Object.entries(packageVersions).filter(([name, versions]) => 
        new Set(versions).size > 1
      );

      // This should be minimal for a clean project
      expect(duplicates.length).toBeLessThan(20);
    });

    test('should have peer dependencies satisfied', () => {
      const peerDepIssues = [];
      
      Object.entries(packageLock.packages).forEach(([key, pkg]) => {
        if (pkg.peerDependencies) {
          Object.entries(pkg.peerDependencies).forEach(([peerName, peerVersion]) => {
            const peerPath = `node_modules/${peerName}`;
            if (packageLock.packages[peerPath]) {
              const installedVersion = packageLock.packages[peerPath].version;
              if (!semver.satisfies(installedVersion, peerVersion)) {
                peerDepIssues.push({
                  package: key,
                  peer: peerName,
                  required: peerVersion,
                  installed: installedVersion
                });
              }
            }
          });
        }
      });

      expect(peerDepIssues).toEqual([]);
    });
  });

  describe('File system integrity', () => {
    test('should have all referenced packages in file system', async () => {
      const nodeModulesPath = path.join(__dirname, '../node_modules');
      const missingPackages = [];

      for (const [key] of Object.entries(packageLock.packages)) {
        if (key.startsWith('node_modules/')) {
          const packagePath = path.join(__dirname, '..', key);
          if (!fs.existsSync(packagePath)) {
            missingPackages.push(key);
          }
        }
      }

      // Some packages might be hoisted or optional
      expect(missingPackages.length).toBeLessThan(5);
    });
  });

  describe('Performance considerations', () => {
    test('should not have excessive dependency depth', () => {
      const maxDepth = 10;
      const deepPackages = [];

      Object.keys(packageLock.packages).forEach(key => {
        if (key.startsWith('node_modules/')) {
          const depth = key.split('/').length - 1;
          if (depth > maxDepth) {
            deepPackages.push({ package: key, depth });
          }
        }
      });

      expect(deepPackages.length).toBe(0);
    });

    test('should have reasonable package count', () => {
      const packageCount = Object.keys(packageLock.packages).filter(key => 
        key.startsWith('node_modules/')
      ).length;

      // Reasonable for a Next.js project with TypeScript and TailwindCSS
      expect(packageCount).toBeLessThan(2000);
      expect(packageCount).toBeGreaterThan(100);
    });
  });
});